<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python爬虫写入CSV]]></title>
      <url>%2F2017%2F06%2F04%2FPython%E7%88%AC%E8%99%AB%E5%86%99%E5%85%A5CSV%2F</url>
      <content type="text"><![CDATA[这次主要练习写入操作，普通基础的爬虫工作做好之后, 可以进行数据分析等等工作，所以爬虫好的数据就要进行写入操作。直接以糗事百科的爬虫当拿手的例子。Talk is cheap, talk is cheap show me the code. 12345678910111213import requestsimport csvfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)csvfile = open(&quot;qiushi.csv&quot;,&quot;a&quot;) writer = csv.writer(csvfile)for link in links: print(link.span.get_text()) writer.writerow([link.span.get_text()])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《自己动手构造编译系统：编译、汇编与链接笔记》1]]></title>
      <url>%2F2017%2F06%2F04%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[从此分类章节开始针对计算机原理进行系统巩固与加深了解，由于工作做软件开发，时常很少能有时间系统的回顾与深入了解计算机系统内部原理，此书是很好的一本书，值得广大同行有兴趣的深入了解与学习。 源代码通过编译器进行编译生成二进制目标文件，然后对目标文件进行链接，最后生成一个可执行文件。可是计算机只能识别二进制指令，因此需要一个已有的程序自动完成汇编语言到二进制指令的翻译工作，于是汇编器就产生了。程序员只需要写出汇编代码，然后交给汇编器进行翻译，生成二进制代码。因此，汇编器将程序员从烦琐的二进制代码中解脱出来。使用汇编器提高了编程的效率，使得人们有能力处理更复杂的计算问题。随着计算问题复杂度的提高，编程中出现了大量的重复代码。人们不愿意进行重复的劳动，于是就想办法将公共的代码提取出来，汇编成独立的模块存储在目标文件中，甚至将同一类的目标文件打包成库。由于原本写在同一个文件内的代码被分割到多个文件中，那么最终还需要将这些分离的文件拼装起来形成完整的可执行代码。但是事情并没有那么简单，由于文件的模块化分割，文件间的符号可能会相互引用。人们需要处理这些引用关系，重新计算符号的引用地址，这就是链接器的基本功能。链接器使得计算机能自动把不同的文件模块准确无误地拼接起来，使得代码的复用成为可能。 链接分为两种，一种是静态链接，另外一种就是动态链接。静态链接器把公用库内的目标文件合并到可执行文件内部，使得可执行文件的体积变得庞大。这样做会导致可执行文件版本难以更新，也导致了多个程序加载后相同的公用库代码占用了多份内存空间。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一)]]></title>
      <url>%2F2017%2F05%2F28%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%E4%B9%8B%E4%BD%BF%E7%94%A8BeautifulSoup%E6%8A%93%E5%8F%96%E6%89%80%E9%9C%80%E5%86%85%E5%AE%B9(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一) 最近由于兴趣使然，对于Python爬虫产生了兴趣，所以平时生活中会抽出功夫学习爬虫，文章是自己的爬虫基础实例，以后博客不仅会有iOS的内容，也会Python爬虫，记录自己的代码生涯。 以糗事百科为例来说明，http://www.qiushibaike.com/text/，抓取原创笑话段子。 .png) 发现内容都在span标签中，如果写 find_all(“span”) 可以抓取到段子的内容，但是还包含了网页上其他span的内容。这时我们往上一级标签上看，&lt;div class=”content&gt; 就是只包含了段子内容的标签。取出来的link的内容就是div，取它的span中的内容就是我们需要段子的内容。 1234567891011import requestsfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)for link in links: print(link.span.get_text())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AutoRelease深入理解原理]]></title>
      <url>%2F2017%2F05%2F13%2FAutoRelease%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？ Autorelease对象什么时候释放？ 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。我们都是知道：所有autorelease的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。但是如果每次都放进应用程序的main.m中的autoreleasepool中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？在一次完整的运行循环结束之前，会被销毁。 那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。 但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。 @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instancetype和id区别]]></title>
      <url>%2F2017%2F05%2F13%2Finstancetype%E5%92%8Cid%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[id在编译的时候不能判断对象的真实类型，而instancetype在编译的时候可以判断对象的真实类型，id和instancetype除了一个在编译时不知道真实类型, 一个在编译时知道真实类型以外, 还有一个区别，id可以用来定义变量, 可以作为返回值, 可以作为形参，instancetype只能用于作为返回值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中self.和下划线的区别]]></title>
      <url>%2F2017%2F03%2F18%2FiOS%E4%B8%ADself.%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[self.xxx 通过访问的方法的引用:包含了set和get方法。而通过_.xxx方法是获取自己的实例变量，不包含set和get方法。 self.xxx是对属性的访问；而xxx是对局部变量的访问。所有被声明为属性的成员，再ios5之前需要使用编译指令@synthesize 来告诉编译器帮助生成属性的getter和setter方法，之后这个指令可以不用认为的指定了，默认情况下编译器会帮助我们生成。编译器在生成getter，setter方法时是有优先级的，他首先查找当前的类中用户是否定义属性的getter，setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。也就是说你在使用self.xxx时是调用一个getter方法。会使引用计数加1，而.xxx不会使用引用技术加1的。 所有使用self.xxx是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在block中造成循环引用。同时使用_.xxx是获取不到父类的属性，因为它只是对局部变量的访问。 最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。]]></content>
    </entry>

    
  
  
</search>
