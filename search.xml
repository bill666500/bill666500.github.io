<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用NSProxy和NSObject设计代理类的差异]]></title>
      <url>%2F2017%2F06%2F12%2F%E4%BD%BF%E7%94%A8NSProxy%E5%92%8CNSObject%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
      <content type="text"><![CDATA[经常发现在一些需要使用消息转发而创建代理类时, 不同的程序员都有着不同的使用方法, 有些采用继承于NSObject, 而有一些采用继承自NSProxy。 二者都是Foundation框架中的基类, 并且都实现了这个接口, 从命名和文档中看NSProxy天生就是用来干这个事情的。 但即便如此, 它们却都定义了相同的消息转发的接口, 那我们在使用二者来完成这个工作时有什么差异呢。 先贴一下通过二者来创建代理类的最基本实现代码。继承自NSProxy 123456789101112131415@interface THProxyA : NSProxy@property (nonatomic, strong) id target;@end@implementation THProxyA- (id)initWithObject:(id)object &#123; self.target = object; return self;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [self.target methodSignatureForSelector:selector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end 继承自NSObject 123456789101112131415161718@interface THProxyB : NSObject@property (nonatomic, strong) id target;@end@implementation THProxyB- (id)initWithObject:(id)object &#123; self = [super init]; if (self) &#123; self.target = object; &#125; return self;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [self.target methodSignatureForSelector:selector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end 代码基本是一致的, 除了初始化时规范的写法有细节差异, 这个差异是因为NSProxy这个基类没有定义默认的init方法。 1.经测试发现以下两个在中定义的接口, 在二者之间表现是不一致的: 1234567NSString *string = @&quot;test&quot;;THProxyA *proxyA = [[THProxyA alloc] initWithObject:string];THProxyB *proxyB = [[THProxyB alloc] initWithObject:string];NSLog(@&quot;%d&quot;, [proxyA respondsToSelector:@selector(length)]);NSLog(@&quot;%d&quot;, [proxyB respondsToSelector:@selector(length)]);NSLog(@&quot;%d&quot;, [proxyA isKindOfClass:[NSString class]]);NSLog(@&quot;%d&quot;, [proxyB isKindOfClass:[NSString class]]); 结果会输出完成不同的结论:121 01 0 也就是说通过继承自NSObject的代理类是不会自动转发respondsToSelector:和isKindOfClass:这两个方法的, 而继承自NSProxy的代理类却是可以的. 测试中定义的其它接口二者表现都是一致的。 2.NSObject的所有Category中定义的方法无法在THProxyB中完成转发 举一个很常见的例子, valueForKey:是定义在NSKeyValueCoding这个NSObject的Category中的方法, 尝试二者执行的表现。 12NSLog(@&quot;%@&quot;,[proxyA valueForKey:@&quot;length&quot;]);NSLog(@&quot;%@&quot;,[proxyB valueForKey:@&quot;length&quot;]); 这段代码第一句能正确运行, 但第二行却会抛出异常, 分析最终原因其实很简单, 因为valueForKey:是NSObject的Category中定义的方法, 让NSObject具备了这样的接口, 而消息转发是只有当接收者无法处理时才会通过forwardInvocation:来寻求能够处理的对象。 3.结论: 如此看来NSProxy确实更适合实现做为消息转发的代理类, 因为作为一个抽象类, NSProxy自身能够处理的方法极小(仅接口中定义的部分方法), 所以其它方法都能够按照设计的预期被转发到被代理的对象中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[信号量dispatch_semaphore的理解及实际运用]]></title>
      <url>%2F2017%2F06%2F11%2F%E4%BF%A1%E5%8F%B7%E9%87%8Fdispatch-semaphore%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%2F</url>
      <content type="text"><![CDATA[信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 信号量为0则阻塞线程，大于0则不会阻塞。因此我们可以通过改变信号量的值，来控制是否阻塞线程，从而达到线程同步。 在GCD中有三个函数是semaphore的操作，分别是：dispatch_semaphore_create 创建一个semaphoredispatch_semaphore_signal 发送一个信号dispatch_semaphore_wait 等待信号 简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。 实际开发中，我们通常会遇到如下问题： 一、某界面存在多个请求，希望所有请求均结束才进行某操作。对于这一问题的解决方案很容易想到通过线程组进行实现，代码如下： 1234567891011121314151617dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求1 [self request_A];&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求2 [self request_B];&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求3 [self request_C];&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //界面刷新 NSLog(@&quot;任务均完成，刷新界面&quot;);&#125;); 这里我们书写一个网络请求通用方法，假设同时请求某新闻列表的3页数据，每页均为一个独立的网络请求。使用我们最常用的AFNet请求，方法如下（真实开发中可能为banner数据请求、主体网络请求、广告网络请求等）： 12345678910111213141516171819- (void)request_A &#123; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; NSDictionary *parameter = @&#123;@&quot;token&quot;:@&quot;63104AB32427EBF89B957BBD1A5C5C11&quot;, @&quot;page&quot;:@&quot;1&quot;, @&quot;upTime&quot;:@&quot;desc&quot;&#125;; [manager POST:URL parameters:parameter progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; for (NSDictionary *rowsDict in dict[@&quot;rows&quot;]) &#123; NSLog(@&quot;A___%@&quot;,rowsDict[@&quot;title&quot;]); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; &#125;];&#125; request_B、request_C分别为请求第二页与第三页数据，这里不重复书写。为了显示更加明显，在请求中打印了对应新闻的标题内容。 12345678910111213141516 任务均完成，刷新界面C___搞笑，不是认真的C___摄影 | 街拍C___生活小窍门C___传统中国C___想吃的美食系列B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐A___左爱情，右面包A___潮我看A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍 运行后马上接收到了线程组完成的提示，之后数据才依次请求下来，很明显三个单纯的AFNet请求已经不能满足我们的需求了。线程组完成时并没有在我们希望的时候给予通知。在真实开发中会造成的问题为多个请求均加载完成，但界面已在未得到数据前提前刷新导致界面空白。 因此对于这种问题需要另辟蹊径，这里我们就要借助GCD中的信号量dispatch_semaphore进行实现，即营造线程同步情况。dispatch_semaphore信号量为基于计数器的一种多线程同步机制。用于解决在多个线程访问共有资源时候，会因为多线程的特性而引发数据出错的问题。 如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。 dispatch_semaphore_signal(semaphore)为计数+1操作。dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。我们将网络请求通用方法进行修改如下： 1234567891011121314151617181920212223242526- (void)request_A &#123; //创建信号量并设置计数默认为0 dispatch_semaphore_t sema = dispatch_semaphore_create(0); AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; NSDictionary *parameter = @&#123;@&quot;token&quot;:@&quot;63104AB32427EBF89B957BBD1A5C5C11&quot;, @&quot;page&quot;:@&quot;1&quot;, @&quot;upTime&quot;:@&quot;desc&quot;&#125;; [manager POST:URL parameters:parameter progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; //计数+1操作 dispatch_semaphore_signal(sema); NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; for (NSDictionary *rowsDict in dict[@&quot;rows&quot;]) &#123; NSLog(@&quot;A___%@&quot;,rowsDict[@&quot;title&quot;]); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; ////计数+1操作 dispatch_semaphore_signal(sema); &#125;]; //若计数为0则一直等待 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&#125; 为方便阅读，伪代码如下： 123456 dispatch_semaphore_t sema = dispatch_semaphore_create(0);[网络请求:&#123; 成功：dispatch_semaphore_signal(sema); 失败：dispatch_semaphore_signal(sema);&#125;];dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); 这时我们再运行程序，打印如下： 12345678910111213141516C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装C___搞笑，不是认真的A___左爱情，右面包A___潮我看A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐任务均完成，刷新界面 运行打印可见，通过信号量dispatch_semaphore完美的解决了此问题，并且网络请求仍为异步，不会堵塞当前主线程。 二、某界面存在多个请求，希望请求依次执行。 对于这个问题通常会通过线程依赖进行解决，因使用GCD设置线程依赖比较繁琐，这里通过NSOperationQueue进行实现，这里采用比较经典的例子，三个任务分别为下载图片，打水印和上传图片，三个任务需异步执行但需要顺序性。代码如下，下载图片、打水印、上传图片仍模拟为分别请求新闻列表3页数据。 12345678910111213141516171819202122//1.任务一：下载图片 NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_A]; &#125;]; //2.任务二：打水印 NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_B]; &#125;]; //3.任务三：上传图片 NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_C]; &#125;]; //4.设置依赖 [operation2 addDependency:operation1]; //任务二依赖任务一 [operation3 addDependency:operation2]; //任务三依赖任务二 //5.创建队列并加入任务 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO]; 首先我们使用未添加信号量dispatch_semaphore时运行，打印如下: 123456789101112131415 B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐A___潮我看A___左爱情，右面包A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍C___盘C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装 根据打印结果可见，若不对请求方法做处理，其运行结果并不是我们想要的，联系实际需求，A、B、C请求分别对应下载图片、打水印、上传图片，而此时运行顺序则为B-&gt;A-&gt;C，在未获得图片时即执行打水印操作明显是错误的。重复运行亦会出现不同结果，即请求不做处理，其结果不可控无法预测。线程依赖设置并未起到作用。 解决此问题的方法仍可通过信号量dispatch_semaphore进行解决。我们将请求方法替换为添加dispatch_semaphore限制的形式。即 123456 dispatch_semaphore_t sema = dispatch_semaphore_create(0);[网络请求:&#123; 成功：dispatch_semaphore_signal(sema); 失败：dispatch_semaphore_signal(sema);&#125;]dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); 再次重复运行，我们会发现每次运行结果均一致，A、B、C三任务异步顺序执行（A-&gt;B-&gt;C） 123456789101112131415 A___潮我看A___左爱情，右面包A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐C___盘C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装 通过重复运行打印结果可证实确实实现了我们想要的效果。这样即解决了所提出的问题二。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己动手构造编译系统：编译、汇编与链接笔记2]]></title>
      <url>%2F2017%2F06%2F07%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B02%2F</url>
      <content type="text"><![CDATA[本次笔记比上次更有难度，因为涉及到汇编的只是，由于汇编涉及的比较底层，而且自己对于汇编有很多还不了解，所以在写完此次课程开始恶补汇编知识，以此来深入理解本书的内容，而且后期的汇编器也深入讨论汇编知识，所以就此通过这次机会学习一下汇编来补习知识。 我们写一个最简单的“HelloWorld”程序，代码存储在源文件hello.c中，源文件内容如下： 123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!&quot;); return 0;&#125; 如果将hello.c编译并静态链接为可执行文件，查看GCC背后的工作流程，可以使用–verbose选项如下(主意针对Mac 命令会有所不同 查看)： 1$gcc hello.c –o hello -S --verbose 通过文件夹目录可以看出多出两个文件 main.s汇编文件和main可执行文件。可以看出，GCC编译背后使用了cc1、as、collect2三个命令。其中cc1是GCC的编译器，它将源文件hello.c编译为hello.s。as是汇编器命令，它将hello.s汇编为hello.o目标文件。collect2是链接器命令，它是对命令ld的封装。静态链接时，GCC将C语言运行时库（CRT）内的5个重要的目标文件crt1.o、crti.o、crtbe-ginT.o、crtend.o、crtn.o以及3个静态库libgcc.a、libgcc_eh.a、libc.a链接到可执行文件hello。此外，cc1在对源文件编译之前，还有预编译的过程。 1.预编译 GCC对源文件的第一阶段的处理是预编译，主要是处理宏定义和文件包含等信息。命令格式如下： 1gcc -E main.c -o main.i 预编译器将hello.c处理后输出到文件hello.i。比如文件包含语句#include，预编译器会将stdio.h的文件内容拷贝到#include语句声明的位置。如果源文件内使用#define语句定义了宏，预编译器则将该宏的内容替换到其被引用的位置。如果宏定义本身使用了其他宏，则预编译器需要将宏递归地展开。 我们可以将预编译的工作简单地理解为源码的文本替换，即将宏定义的内容替换到宏的引用位置。当然，这样理解有一定的片面性，因为要考虑宏定义中使用其他宏的情况。事实上预编译器的实现机制和编译器有着很大的相似性，因此本书描述的编译系统将重点放在源代码的编译上，不再独立实现预编译器。然而，我们需要清楚的事实是：一个完善的编译器是需要预编译器的。 2.编译 接下来GCC对hello.i进行编译，命令如下： 1$gcc –S hello.i –o hello.s编译后产生的汇编文件hello.s 3.汇编 接着，GCC使用汇编器对hello.s进行汇编，命令如下： 1$gcc –c hello.s –o hello.o 生成的目标文件hello.o，Linux下称之为可重定位目标文件。目标文件无法使用文本编辑器直接查看，但是我们可以使用GCC自带的工具objdump命令分析它的内容，命令格式如下： 1$objdump –sd hello.o 从数据段二进制信息的ASCII形式的显示中，我们看到了汇编语言内定义的字符串数据“Hello World！”。代码段的信息和汇编文件代码信息基本吻合，但是我们发现了很多不同之处。比如汇编文件内的指令“movl$.LC0，%eax”中的符号.LC0的地址（字符串“Hello World！”的地址）被换成了0。指令“callprintf”内符号printf的相对地址被换成了0xfffffffc，即call指令操作数部分的起始地址。这些区别本质来源于汇编语言符号的引用问题。由于汇编器在处理当前文件的过程中无法获悉符号的虚拟地址，因此临时将这些符号地址设置为默认值0，真正的符号地址只有在链接的时候才能确定。 4.链接 使用GCC命令进行目标文件链接很简单： 1gcc hello.o –o hello GCC默认使用动态链接，如果要进行静态链接，需加上-static选项： 1gcc hello.o –o hello –static 这样生成的可执行文件hello便能正常执行了。我们使用objdump命令查看一下静态链接后的可执行文件内的信息。由于可执行文件中包含了大量的C语言库文件，因此这里不便将文件的所有信息展示出来，仅显示最终main函数的可执行代码。 从main函数的可执行代码中，我们发现汇编过程中描述的无法确定的符号地址信息在这里都被修正为实际的符号地址。如“Hello World！”字符串的地址为0x080ae828，printf函数的地址为0x08048dd0。这里符号_IO_printf与printf完全等价，call指令内部相对地址为0x000afa，正好是printf地址相对于call指令下条指令起始地址0x080482d6的偏移。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫写入CSV]]></title>
      <url>%2F2017%2F06%2F04%2FPython%E7%88%AC%E8%99%AB%E5%86%99%E5%85%A5CSV%2F</url>
      <content type="text"><![CDATA[这次主要练习写入操作，普通基础的爬虫工作做好之后, 可以进行数据分析等等工作，所以爬虫好的数据就要进行写入操作。直接以糗事百科的爬虫当拿手的例子。Talk is cheap, talk is cheap show me the code. 12345678910111213import requestsimport csvfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)csvfile = open(&quot;qiushi.csv&quot;,&quot;a&quot;) writer = csv.writer(csvfile)for link in links: print(link.span.get_text()) writer.writerow([link.span.get_text()])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《自己动手构造编译系统：编译、汇编与链接笔记》1]]></title>
      <url>%2F2017%2F06%2F04%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[从此分类章节开始针对计算机原理进行系统巩固与加深了解，由于工作做软件开发，时常很少能有时间系统的回顾与深入了解计算机系统内部原理，此书是很好的一本书，值得广大同行有兴趣的深入了解与学习。 源代码通过编译器进行编译生成二进制目标文件，然后对目标文件进行链接，最后生成一个可执行文件。可是计算机只能识别二进制指令，因此需要一个已有的程序自动完成汇编语言到二进制指令的翻译工作，于是汇编器就产生了。程序员只需要写出汇编代码，然后交给汇编器进行翻译，生成二进制代码。因此，汇编器将程序员从烦琐的二进制代码中解脱出来。使用汇编器提高了编程的效率，使得人们有能力处理更复杂的计算问题。随着计算问题复杂度的提高，编程中出现了大量的重复代码。人们不愿意进行重复的劳动，于是就想办法将公共的代码提取出来，汇编成独立的模块存储在目标文件中，甚至将同一类的目标文件打包成库。由于原本写在同一个文件内的代码被分割到多个文件中，那么最终还需要将这些分离的文件拼装起来形成完整的可执行代码。但是事情并没有那么简单，由于文件的模块化分割，文件间的符号可能会相互引用。人们需要处理这些引用关系，重新计算符号的引用地址，这就是链接器的基本功能。链接器使得计算机能自动把不同的文件模块准确无误地拼接起来，使得代码的复用成为可能。 链接分为两种，一种是静态链接，另外一种就是动态链接。静态链接器把公用库内的目标文件合并到可执行文件内部，使得可执行文件的体积变得庞大。这样做会导致可执行文件版本难以更新，也导致了多个程序加载后相同的公用库代码占用了多份内存空间。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一)]]></title>
      <url>%2F2017%2F05%2F28%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%E4%B9%8B%E4%BD%BF%E7%94%A8BeautifulSoup%E6%8A%93%E5%8F%96%E6%89%80%E9%9C%80%E5%86%85%E5%AE%B9(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一) 最近由于兴趣使然，对于Python爬虫产生了兴趣，所以平时生活中会抽出功夫学习爬虫，文章是自己的爬虫基础实例，以后博客不仅会有iOS的内容，也会Python爬虫，记录自己的代码生涯。 以糗事百科为例来说明，http://www.qiushibaike.com/text/，抓取原创笑话段子。 .png) 发现内容都在span标签中，如果写 find_all(“span”) 可以抓取到段子的内容，但是还包含了网页上其他span的内容。这时我们往上一级标签上看，&lt;div class=”content&gt; 就是只包含了段子内容的标签。取出来的link的内容就是div，取它的span中的内容就是我们需要段子的内容。 1234567891011import requestsfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)for link in links: print(link.span.get_text())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AutoRelease深入理解原理]]></title>
      <url>%2F2017%2F05%2F13%2FAutoRelease%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？ Autorelease对象什么时候释放？ 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。我们都是知道：所有autorelease的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。但是如果每次都放进应用程序的main.m中的autoreleasepool中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？在一次完整的运行循环结束之前，会被销毁。 那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。 但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。 @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instancetype和id区别]]></title>
      <url>%2F2017%2F05%2F13%2Finstancetype%E5%92%8Cid%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[id在编译的时候不能判断对象的真实类型，而instancetype在编译的时候可以判断对象的真实类型，id和instancetype除了一个在编译时不知道真实类型, 一个在编译时知道真实类型以外, 还有一个区别，id可以用来定义变量, 可以作为返回值, 可以作为形参，instancetype只能用于作为返回值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中self.和下划线的区别]]></title>
      <url>%2F2017%2F03%2F18%2FiOS%E4%B8%ADself.%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[self.xxx 通过访问的方法的引用:包含了set和get方法。而通过_.xxx方法是获取自己的实例变量，不包含set和get方法。 self.xxx是对属性的访问；而xxx是对局部变量的访问。所有被声明为属性的成员，再ios5之前需要使用编译指令@synthesize 来告诉编译器帮助生成属性的getter和setter方法，之后这个指令可以不用认为的指定了，默认情况下编译器会帮助我们生成。编译器在生成getter，setter方法时是有优先级的，他首先查找当前的类中用户是否定义属性的getter，setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。也就是说你在使用self.xxx时是调用一个getter方法。会使引用计数加1，而.xxx不会使用引用技术加1的。 所有使用self.xxx是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在block中造成循环引用。同时使用_.xxx是获取不到父类的属性，因为它只是对局部变量的访问。 最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。]]></content>
    </entry>

    
  
  
</search>
