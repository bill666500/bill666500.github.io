<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React-Native解决iOS项目编译问题]]></title>
      <url>%2F2017%2F09%2F13%2FReact-Native%E8%A7%A3%E5%86%B3iOS%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[React-Native解决iOS项目编译问题 在平时做项目中，我们很可能通过pod方式引入React Native，看网上资料大多数还是解决不了0.46以上的问题，目前个人用的是0.47.1版本，大多数网上资料针对最新版已经不适用了，大多数类似在podfile文件添加： 1234567891011pod &apos;React&apos;, :path =&gt; &apos;./Test/node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] 可是始终编译不通过， 纳尼，难道我自己安装的环境不行，结果不得不去谷歌一下，但是第一个我搜了没有相应想要的信息，好吧，我从最后面那条信息入手_JSNoBytecodeFileFormatVersion,referenced from:很快就找到答案 在此链接我们找到了想要的答案 最终要在podfile文件添加： 123456789101112pod &apos;React&apos;, :path =&gt; &apos;./Test/node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, &apos;BatchedBridge&apos; ] 这样就可以完美解决0.46以上版本编译不通过的问题。下回有时间介绍下在项目中针对RN遇到的一些麻烦问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native 之新手入门进阶一]]></title>
      <url>%2F2017%2F09%2F06%2FReact-Native-%E4%B9%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B6%E4%B8%80%2F</url>
      <content type="text"><![CDATA[React Native 之新手入门进阶一 1.1 React Native 简单介绍 React Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。 1.2 React Native的优势 跨平台＋动态更新 传统的客户端开发模式是怎样的呢？ Android 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。 不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。 对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。 相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。 代码复用一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。而最近 Instagram 的官博 React Native at Instagram 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 85% - 99% 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。1.3 React Native的劣势学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。 安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说,查看了下资料需要用 split apk 的技术就能缩小到到 1MB 左右的增幅。 首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。 2 React Native 运行机制 对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是： 同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性 开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发 由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术 Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法 Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态 3 React Native 开发环境搭建 ###使用React Native开发iOS应用需要OSX系统，Xcode，Homebrew，node，npm ###3.1 安装Homebrew 12345Homebrew, 简称brew, Mac系统的包管理器, 用于安装NodeJS和一些其他必需的工具软件。Home-brew 的使用方式:1)搜索软件：brew search 软件名，如brew search wget2)安装软件：brew install 软件名，如brew install wget3)卸载软件：brew remove 软件名，如brew remove wget 打开终端，运行以下语句（中间需要输入密码）进行安装： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 可通过如下语句查看安装是否成功以及安装的Homebrew版本： 1brew -v 正常情况下均可安装成功，若出现网络问题安装失败，则运行如下语句清理后再重新安装： 12ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ###3.2 使用Homebrew来安装Node.js 终端运行语句如下： 1brew install node 安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global ###3.3 Yarn、React Native的命令行工具（react-native-cli） Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 1npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源： 12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权： 1sudo chown -R `whoami` /usr/local ###3.4 React Native开发之IDE 1231.WebStorm2.Sublime Text3.Atom 4 创建一个RN项目 ###4.1 初始化创建项目 切换到指定目录文件路径之后，命令行创建项目： 1react-native init RNDemo ###4.2 初始化创建项目12345// 视情况而定，总之进入项目根目录cd RNDemo// 运行iOS项目react-native run-ios ###4.3 iOS原生运行方法 双击ios/AwesomeProject.xcodeproj文件然后在Xcode中点击Run按钮。（最常用，对iOS开发者） ###4.4 简单的修改调试 使用你喜欢的编辑器打开index.ios.js并随便改上几行。在iOS Emulator中按下⌘-R就可以刷新APP并看到你的最新修改！ 最后总结：这只是入门的第一篇，接下来有时间会陆续更新项目遇到的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Block的使用注意事项]]></title>
      <url>%2F2017%2F07%2F27%2FBlock%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[Block的使用注意事项 防止循环引用 众所周知，Block 在使用的时候默认会使对象的引用计数加一，所以我们需要使用 __weak 关键字来防止对象（主要是指拥有此 Block 所在对象的控制器）和 Block 循环引用。如下代码所示： 123456MyViewController *myController = [[MyViewController alloc] init…]; // ...MyViewController * __weak weakMyViewController = myController;myController.completionHandler = ^(NSInteger result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 但是这样就可以了吗？假如是多线程的情况下，weakMyViewController已经释放了，那么就会发生闪退现象，不信我们可以做个试验，talk is cheap, show me the code. 我们做个试验，有两个ViewController,两个ViewController都有按钮触发事件，关键代码如下：ViewController.m文件 123456789101112131415161718192021222324252627#import &quot;ViewController.h&quot;#import &quot;CustomController.h&quot;@interface ViewController ()- (IBAction)clickAction:(id)sender;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;- (IBAction)clickAction:(id)sender &#123; CustomController *custom = [[CustomController alloc] init]; [self presentViewController:custom animated:YES completion:nil];&#125;@end CustomController.m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;CustomController.h&quot;typedef void(^CustomBlock)();typedef void(^LogBlock)();@interface CustomController ()@property (nonatomic, copy) CustomBlock block;@property (nonatomic, copy) LogBlock logBlock;- (IBAction)clickAction:(id)sender;@end@implementation CustomController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = [UIColor whiteColor]; __weak typeof(self) weakSelf = self; self.logBlock = ^&#123; NSLog(@&quot;%@&quot;,weakSelf); &#125;; self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; weakSelf.logBlock(); &#125;); &#125;;&#125;- (IBAction)clickAction:(id)sender &#123; self.block(); [self dismissViewControllerAnimated:YES completion:nil];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 运行结果不难发现我们直接闪退，纳尼，一看weakSelf是nil!!! 那我们怎么办呢？这是为后面做的铺垫，请看下面。 Weak-Strong Dance 什么是 Weak-Strong Dance ？ 在使用的 Block 时， 除了使用 weak 修饰符去避免循环引用外，还可以通过名为 Weak-Strong Dance 的方式去避免循环引用。 其实 Weak-Strong Dance 并不是一个新东西，它只是 weak 的一个升级版本。主要目的是为了避免在极端情况下 __weak 这种情况会出现的问题。 按照上面的代码我们做些修改，只改ViewDidLoad中的self.block里面的即可。代码如下: 123456self.block = ^&#123; __strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; strongSelf.logBlock(); &#125;); &#125;; 这样我们就可以正常运行了，没有闪退。strong typeof(weakSelf)strongSelf = weakSelf;就是解决这个问题的关键~先将强引用的对象转为弱引用指针，防止了 Block 和对象之间的循环引用。再在 Block 的第一句代码出将 weakSelf 的弱引用转换成 strongSelf 这样的强引用指针，防止了多线程和 ARC 环境下弱引用随时被释放的问题（因为强引用的引用计数至少为1）。 这样就可以安心使用了吗？NO!!! 请看下文。 Weak-Strong Dance真的安全吗？ 会有什么问题吗？有，假如在执行__strong typeof(self) strongSelf = weakSelf;这句之前weakSelf已经释放了？怎么办？我们还是按照上文的例子继续改造，这样运行结果能说明问题。代码如下: 12345678self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; __strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; strongSelf.logBlock(); &#125;); &#125;); &#125;; 我们执行下，结果如下：纳尼？逗我玩儿? strongSelf 居然为nil，是滴，这就是我们要说的上述可能会存在的问题。所以需要继续改造才可以，代码如下: 123456789101112self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; __strong typeof(self) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if(strongSelf) &#123; strongSelf.logBlock(); &#125; else &#123; NSLog(@&quot;strongSelf = nil!!!&quot;); &#125; &#125;); &#125;); &#125;; 这样就可以解决闪退问题，因为可能strongSelf为nil, 所以需要判断即可。这样才算真正的解决Block的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[App卡顿监测]]></title>
      <url>%2F2017%2F07%2F14%2FApp%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[由于最近需求多忙于工作，最近很少更新博客了，希望这段时间能够多花时间谢谢博客，补充技术技能。今天要介绍的RunLoop使用场景很有意思，在做长期项目，需要跟踪解决用户问题非常有用。使用RunLoop 监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来，下次上传到服务器。 参考资料 关于今天要介绍的使用RunLoop 监测主线程卡顿的资料如下： 微信iOS卡顿监控系统（这篇文章要首先阅读，了解有哪些情况会引起主线程卡顿，监测到卡顿后怎么处理等）简单监测iOS卡顿的demo （使用RunLoop监测卡顿的例子） 原理 官方文档说明了RunLoop的执行顺序： 12345678910111213141516171. Notify observers that the run loop has been entered.2. Notify observers that any ready timers are about to fire.3. Notify observers that any input sources that are not port based are about to fire.4. Fire any non-port-based input sources that are ready to fire.5. If a port-based input source is ready and waiting to fire, process the event immediately. Go to step 9.6. Notify observers that the thread is about to sleep.7. Put the thread to sleep until one of the following events occurs: * An event arrives for a port-based input source. * A timer fires. * The timeout value set for the run loop expires. * The run loop is explicitly woken up.8. Notify observers that the thread just woke up.9. Process the pending event. * If a user-defined timer fired, process the timer event and restart the loop. Go to step 2. * If an input source fired, deliver the event. * If the run loop was explicitly woken up but has not yet timed out, restart the loop. Go to step 2.10. Notify observers that the run loop has exited. 用伪代码来实现就是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041/// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit); 主线程的RunLoop是在应用启动时自动开启的，也没有超时时间，所以正常情况下，主线程的RunLoop 只会在 2—9 之间无限循环下去。那么，我们只需要在主线程的RunLoop中添加一个observer，检测从 kCFRunLoopBeforeSources 到 kCFRunLoopBeforeWaiting 花费的时间 是否过长。如果花费的时间大于某一个阙值，我们就认为有卡顿，并把当前的线程堆栈转储到文件中，并在以后某个合适的时间，将卡顿信息文件上传到服务器。 实现步骤 在看了上面的两个监测卡顿的示例Demo后，我按照上面讲述的思路写了一个Demo，应该更容易理解吧。第一步，创建一个子线程，在线程启动时，启动其RunLoop。 123456789101112131415161718192021+ (instancetype)shareMonitor&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[[self class] alloc] init]; instance.monitorThread = [[NSThread alloc] initWithTarget:self selector:@selector(monitorThreadEntryPoint) object:nil]; [instance.monitorThread start]; &#125;); return instance;&#125;+ (void)monitorThreadEntryPoint&#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;FluencyMonitor&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; 第二步，在开始监测时，往主线程的RunLoop中添加一个observer，并往子线程中添加一个定时器，每0.5秒检测一次耗时的时长。 12345678910111213141516171819202122232425262728293031323334- (void)start&#123; if (_observer) &#123; return; &#125; // 1.创建observer CFRunLoopObserverContext context = &#123;0,(__bridge void*)self, NULL, NULL, NULL&#125;; _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); // 2.将observer添加到主线程的RunLoop中 CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); // 3.创建一个timer，并添加到子线程的RunLoop中 [self performSelector:@selector(addTimerToMonitorThread) onThread:self.monitorThread withObject:nil waitUntilDone:NO modes:@[NSRunLoopCommonModes]];&#125;- (void)addTimerToMonitorThread&#123; if (_timer) &#123; return; &#125; // 创建一个timer CFRunLoopRef currentRunLoop = CFRunLoopGetCurrent(); CFRunLoopTimerContext context = &#123;0, (__bridge void*)self, NULL, NULL, NULL&#125;; _timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.01, 0, 0, &amp;runLoopTimerCallBack, &amp;context); // 添加到子线程的RunLoop中 CFRunLoopAddTimer(currentRunLoop, _timer, kCFRunLoopCommonModes);&#125; 第三步，补充观察者回调处理 1234567891011121314151617181920212223242526272829static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; FluencyMonitor *monitor = (__bridge FluencyMonitor*)info; NSLog(@&quot;MainRunLoop---%@&quot;,[NSThread currentThread]); switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;kCFRunLoopEntry&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;kCFRunLoopBeforeSources&quot;); monitor.startDate = [NSDate date]; monitor.excuting = YES; break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); monitor.excuting = NO; break; case kCFRunLoopAfterWaiting: NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); break; case kCFRunLoopExit: NSLog(@&quot;kCFRunLoopExit&quot;); break; default: break; &#125;&#125; 从打印信息来看，RunLoop进入睡眠状态的时间可能会非常短，有时候只有1毫秒，有时候甚至1毫秒都不到，静止不动时，则会长时间进入睡觉状态。 因为主线程中的block、交互事件、以及其他任务都是在kCFRunLoopBeforeSources 到 kCFRunLoopBeforeWaiting 之前执行，所以我在即将开始执行Sources 时，记录一下时间，并把正在执行任务的标记置为YES，将要进入睡眠状态时，将正在执行任务的标记置为NO。 第四步，补充timer 的回调处理 1234567891011121314151617static void runLoopTimerCallBack(CFRunLoopTimerRef timer, void *info)&#123; FluencyMonitor *monitor = (__bridge FluencyMonitor*)info; if (!monitor.excuting) &#123; return; &#125; // 如果主线程正在执行任务，并且这一次loop 执行到 现在还没执行完，那就需要计算时间差 NSTimeInterval excuteTime = [[NSDate date] timeIntervalSinceDate:monitor.startDate]; NSLog(@&quot;定时器---%@&quot;,[NSThread currentThread]); NSLog(@&quot;主线程执行了---%f秒&quot;,excuteTime); if (excuteTime &gt;= 0.01) &#123; NSLog(@&quot;线程卡顿了%f秒&quot;,excuteTime); [monitor handleStackInfo]; &#125;&#125; timer 每 0.01秒执行一次，如果当前正在执行任务的状态为YES，并且从开始执行到现在的时间大于阙值，则把堆栈信息保存下来，便于后面处理。为了能够捕获到堆栈信息，我把timer的间隔调的很小（0.01），而评定为卡顿的阙值也调的很小（0.01）。 实际使用时这两个值应该是比较大，timer间隔为1s，卡顿阙值为2s即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性的本质2]]></title>
      <url>%2F2017%2F06%2F15%2F%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A82%2F</url>
      <content type="text"><![CDATA[接着上一章节，我们来利用runtime实现属性，思路利用runtime.h文件的2个函数完成操作，如下面所示： 1234567891011/** * Adds a property to a class. * * @param cls 修改的类 * @param name 属性名字 * @param attributes 属性数组 * @param attributeCount 属性数组数量 * @return y 成功,n失败 */OBJC_EXPORT BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0); 123456789101112131415161718/** * Adds a new method to a class with a given name and implementation. * * @param cls The class to which to add a method.//添加方法名字 * @param name A selector that specifies the name of the method being added.//方法名称 * @param imp A function which is the implementation of the new method. The function must take at least two arguments—self and _cmd.//方法的实现必须至少2个参数,self 和 _cmd * @param types An array of characters that describe the types of the arguments to the method. //描述 * * @return YES if the method was added successfully, otherwise NO //y成功,n失败 * (for example, the class already contains a method implementation with that name). * * @note class_addMethod will add an override of a superclass&apos;s implementation, //会覆盖superclass 的实现; * but will not replace an existing implementation in this class. //已经存在的不会替换 * To change an existing implementation, use method_setImplementation.//想要改变,使用method_setImplementation方法 */OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0); 还是老话，talk is cheap, show me the code~我们要生成一个name的属性;结果要跟@property 一样; 1. 生成属性 123456objc_property_attribute_t type = &#123; &quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot; &#125;;objc_property_attribute_t ownership = &#123; &quot;C&quot;, &quot;&quot; &#125;; // C = copyobjc_property_attribute_t nonatomic = &#123; &quot;N&quot;, &quot;&quot; &#125;; //nonatomicobjc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_name&quot; &#125;;//V 实例变量objc_property_attribute_t attrs[] = &#123; type, ownership,nonatomic, backingivar &#125;;class_addProperty([self class], &quot;name&quot;, attrs, 4); 2. 生成方法 123456789101112131415161718192021222324252627282930NSString *nameGetter(id self, SEL _cmd) &#123; Ivar ivar = class_getInstanceVariable([self class], &quot;_privateName&quot;); return object_getIvar(self, ivar);&#125;void myNameSetter(id self, SEL _cmd, NSString *newName) &#123; Ivar ivar = class_getInstanceVariable([self class], &quot;_privateName&quot;); id oldName = object_getIvar(self, ivar); if (oldName != newName) object_setIvar(self, ivar, [newName copy]);&#125;//其中 “v@:” 表示返回值和参数if(class_addMethod([self class], NSSelectorFromString(@&quot;name&quot;), (IMP)nameGetter, &quot;@@:&quot;))&#123; NSLog(@&quot;name get 方法添加成功&quot;);&#125;else&#123; NSLog(@&quot;name get 方法添加失败&quot;);&#125;if(class_addMethod([self class], NSSelectorFromString(@&quot;setName:&quot;), (IMP)nameSetter, &quot;v@:@&quot;))&#123; NSLog(@&quot;name set 方法添加成功&quot;);&#125;else&#123; NSLog(@&quot;name set 方法添加失败&quot;);&#125; 3. 打印结果 12345678方法列表: ( &quot;setName:&quot;, &quot;name&quot;, &quot;touchesBegan:withEvent:&quot;, &quot;viewDidLoad&quot;, &quot;.cxx_destruct&quot;, &quot;setName:&quot;, &quot;name&quot;, 4. 扩展 cxx_destruct 字面意思是自毁方法? 我们从第一篇代码结果显示会有这个，那这个到底是什么意思呢？查找资料可以根据这篇博客:http://blog.jobbole.com/65028/来了解一下：.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作。 1231.只有在ARC下这个方法才会出现（试验代码的情况下）2.只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法3.出现这个方法和变量是否被赋值，赋值成什么没有关系 至此我们针对属性的本质有了深入的了解，争取以后每天都写博客针对OC、计算机原理，当然还有Python爬虫，最近由于时间紧工作忙碌，没有来得及写Python爬虫博客和做一些Demo，为此争取多挤出一些时间来写下，有了爬虫技术才能有数据，有数据就可以做分析了~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[属性的本质1]]></title>
      <url>%2F2017%2F06%2F13%2F%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
      <content type="text"><![CDATA[@property 的本质是什么？ 1@property = ivar + getter + setter 1.验证 talk is cheap, show me the code~ 我们在类里面添加个属性 1234567#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@property (nonatomic, copy) NSString *name;@end 在实现方法里代码如下: 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; unsigned int count; objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count); for (unsigned int i = 0; i&lt; count; i++) &#123; const char *name = property_getName(propertyList[i]); NSLog(@&quot;__%@&quot;,[NSString stringWithUTF8String:name]); objc_property_t property = propertyList[i]; const char *a = property_getAttributes(property); NSLog(@&quot;属性信息__%@&quot;,[NSString stringWithUTF8String:a]); &#125; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 输出结果为: 12__name属性信息__T@&quot;NSString&quot;,C,N,V_name 再利用class_copyMethodList查看方法列表 123456789101112u_int methodCount;NSMutableArray *methodList = [NSMutableArray array];Method *methods = class_copyMethodList([self class], &amp;methodCount);for (int i = 0; i &lt; methodCount; i++)&#123; SEL name = method_getName(methods[i]); NSString *strName = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; [methodList addObject:strName];&#125;free(methods);NSLog(@&quot;方法列表:%@&quot;,methodList); 结果: 1234567方法列表: ( &quot;.cxx_destruct&quot;, name, didReceiveMemoryWarning, viewDidLoad, &quot;setName:&quot;,) 分析1属性信息__T@&quot;NSString&quot;,C,N,V_name 这一堆信息是什么?翻阅Objective-C Runtime Programming Guide https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html 找到线索，不难发现 12345//T@&quot;NSString&quot;,C,N,V_name//T 类型//C copy//N nonatomic//V 实例变量 最终可以看出@property = ivar + getter + setter下篇讲解利用runtime实现的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己动手构造编译系统：编译、汇编与链接笔记3]]></title>
      <url>%2F2017%2F06%2F12%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B03%2F</url>
      <content type="text"><![CDATA[2.1 编译程序的设计 编译器是编译系统的核心，主要负责解析源程序的语义，生成目标机器代码。一般情况下，编译流程包含词法分析、语法分析、语义分析和代码生成四个阶段。符号表管理和错误处理贯穿于整个编译流程。如果编译器支持代码优化，那么还需要优化器模块。 2.1.1 词法分析 现在假定我们拥有一段使用C语言书写的源程序，词法分析器通过对源文件的扫描获得高级语言定义的词法记号。所谓词法记号（也称为终结符），反映在高级语言语法中就是对应的标识符、关键字、常量，以及运算符、逗号、分号等界符。 对词法分析器的要求是能正常识别出这些不同形式的词法记号。词法分析器的输入是源代码文本文件内一长串的文本内容，那么如何从文本串中分析出每个词法记号呢？为了解决这个问题，需要引入有限自动机的概念。 有限自动机能解析并识别词法记号，比如识别标识符的有限自动机、识别常量的有限自动机等。有限自动机从开始状态启动，读入一个字符作为输入，并根据该字符选择进入下一个状态。继续读入新的字符，直到遇到结束状态为止，读入的所有字符序列便是有限自动机识别的词法记号。 使用有限自动机，可以识别出自定义语言包含的所有词法记号。把这些词法记号记录下来，作为下一步语法分析的输入。如果使用一遍编译方式，就不用记录这些词法记号，而是直接将识别的词法记号送入语法分析器进行处理。 2.1.2 语法分析 词法分析器的输入是文本字符串，语法分析器的输入则是词法分析器识别的词法记号序列。语法分析器的输出不再是一串线性符号序列，而是一种树形的数据结构，通常称之为抽象语法树。 继续前面赋值语句的例子，我们可以先看看它可能对应的抽象语法树: 所有的词法记号都出现在树的叶子节点上，我们称这样的叶子节点为终结符。而所有的非叶子节点，都是对一串词法记号的抽象概括，我们称之为非终结符，可以将非终结符看作一个单独的语法模块（抽象语法子树）。其实，整个源程序是一棵完整的抽象语法树，它由一系列语法模块按照树结构组织起来。语法分析器就是要获得源程序的抽象语法树表示，这样才能让编译器具体识别每个语法模块的含义，分析出程序的整体含义。 在介绍语法分析器的工作之前，需要先获得高级语言语法的形式化表示，即文法。文法定义了源程序代码的书写规则，同时也是语法分析器构造抽象语法树的规则。如果要定义赋值语句的文法，一般可以表达成如下产生式的形式： 1&lt;赋值语句&gt;=&gt;标识符等号&lt;表达式&gt;分号 被“&lt;&gt;”括起来的内容表示非终结符，终结符直接书写即可，上式可以读作“赋值语句推导出标识符、等号、表达式和分号”。显然，表达式也有相关的文法定义。根据定义好的高级语言特性，可以设计出相应的高级语言的文法，使用文法可以准确地表达高级语言的语法规则。 有了高级语言的文法表示，就可以构造语法分析器来生成抽象语法树。在编译原理教材中，描述了很多的文法分析算法，有自顶向下的LL（1）分析，也有自底向上的算符优先分析、LR分析等。其中最常使用的是LL（1）和LR分析。相比而言，LR分析器能力更强，但是分析器设计比较复杂，不适合手工构造。我们设计的高级语言文法，只要稍加约束便能使LL（1）分析器正常工作，因此本书采用LL（1）分析器来完成语法分析的工作。递归下降子程序作为LL（1）算法的一种便捷的实现方式，非常适合手工实现语法分析器。 递归下降子程序的基本原则是：将产生式左侧的非终结符转化为函数定义，将产生式右侧的非终结符转化为函数调用，将终结符转化为词法记号匹配。例如前面提到的赋值语句对应的子程序的伪代码大致是这样的。 123456void 赋值语句()&#123; match(标识符); match(等号);表达式();match(分号);&#125; 每次对子程序的调用，就是按照前序的方式对该抽象语法子树的一次构造。例如在构造赋值语句子树时，会先构造“赋值语句”根节点，然后依次匹配标识符、等号子节点。当遇到下一个非终结符时，会进入对应的“表达式”子程序内继续按照前序方式构造子树的子树。最后匹配当前子程序的最后一个子节点，完成“赋值语句”子树的构造。整个语法分析就是按照这样的方式构造“程序”树的一个过程，一旦在终结符匹配过程中出现读入的词法记号与预期的词法记号不吻合的情况，便会产生语法错误。 在实际语法分析器实现中，并不一定要显式地构造出抽象语法树。递归下降子程序实现的语法分析器，使得抽象语法树的语法模块都蕴含在每次子程序的执行中，即每次子程序的正确执行都表示识别了对应的语法模块。因此，可以在语法分析子程序中直接进行后续的工作，如语义分析及代码生成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用NSProxy和NSObject设计代理类的差异]]></title>
      <url>%2F2017%2F06%2F12%2F%E4%BD%BF%E7%94%A8NSProxy%E5%92%8CNSObject%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
      <content type="text"><![CDATA[经常发现在一些需要使用消息转发而创建代理类时, 不同的程序员都有着不同的使用方法, 有些采用继承于NSObject, 而有一些采用继承自NSProxy。 二者都是Foundation框架中的基类, 并且都实现了这个接口, 从命名和文档中看NSProxy天生就是用来干这个事情的。 但即便如此, 它们却都定义了相同的消息转发的接口, 那我们在使用二者来完成这个工作时有什么差异呢。 先贴一下通过二者来创建代理类的最基本实现代码。继承自NSProxy 123456789101112131415@interface THProxyA : NSProxy@property (nonatomic, strong) id target;@end@implementation THProxyA- (id)initWithObject:(id)object &#123; self.target = object; return self;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [self.target methodSignatureForSelector:selector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end 继承自NSObject 123456789101112131415161718@interface THProxyB : NSObject@property (nonatomic, strong) id target;@end@implementation THProxyB- (id)initWithObject:(id)object &#123; self = [super init]; if (self) &#123; self.target = object; &#125; return self;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [self.target methodSignatureForSelector:selector];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end 代码基本是一致的, 除了初始化时规范的写法有细节差异, 这个差异是因为NSProxy这个基类没有定义默认的init方法。 1.经测试发现以下两个在中定义的接口, 在二者之间表现是不一致的: 1234567NSString *string = @&quot;test&quot;;THProxyA *proxyA = [[THProxyA alloc] initWithObject:string];THProxyB *proxyB = [[THProxyB alloc] initWithObject:string];NSLog(@&quot;%d&quot;, [proxyA respondsToSelector:@selector(length)]);NSLog(@&quot;%d&quot;, [proxyB respondsToSelector:@selector(length)]);NSLog(@&quot;%d&quot;, [proxyA isKindOfClass:[NSString class]]);NSLog(@&quot;%d&quot;, [proxyB isKindOfClass:[NSString class]]); 结果会输出完成不同的结论:121 01 0 也就是说通过继承自NSObject的代理类是不会自动转发respondsToSelector:和isKindOfClass:这两个方法的, 而继承自NSProxy的代理类却是可以的. 测试中定义的其它接口二者表现都是一致的。 2.NSObject的所有Category中定义的方法无法在THProxyB中完成转发 举一个很常见的例子, valueForKey:是定义在NSKeyValueCoding这个NSObject的Category中的方法, 尝试二者执行的表现。 12NSLog(@&quot;%@&quot;,[proxyA valueForKey:@&quot;length&quot;]);NSLog(@&quot;%@&quot;,[proxyB valueForKey:@&quot;length&quot;]); 这段代码第一句能正确运行, 但第二行却会抛出异常, 分析最终原因其实很简单, 因为valueForKey:是NSObject的Category中定义的方法, 让NSObject具备了这样的接口, 而消息转发是只有当接收者无法处理时才会通过forwardInvocation:来寻求能够处理的对象。 3.结论: 如此看来NSProxy确实更适合实现做为消息转发的代理类, 因为作为一个抽象类, NSProxy自身能够处理的方法极小(仅接口中定义的部分方法), 所以其它方法都能够按照设计的预期被转发到被代理的对象中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[信号量dispatch_semaphore的理解及实际运用]]></title>
      <url>%2F2017%2F06%2F11%2F%E4%BF%A1%E5%8F%B7%E9%87%8Fdispatch-semaphore%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%2F</url>
      <content type="text"><![CDATA[信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 信号量为0则阻塞线程，大于0则不会阻塞。因此我们可以通过改变信号量的值，来控制是否阻塞线程，从而达到线程同步。 在GCD中有三个函数是semaphore的操作，分别是：dispatch_semaphore_create 创建一个semaphoredispatch_semaphore_signal 发送一个信号dispatch_semaphore_wait 等待信号 简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。 实际开发中，我们通常会遇到如下问题： 一、某界面存在多个请求，希望所有请求均结束才进行某操作。对于这一问题的解决方案很容易想到通过线程组进行实现，代码如下： 1234567891011121314151617dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求1 [self request_A];&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求2 [self request_B];&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //请求3 [self request_C];&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //界面刷新 NSLog(@&quot;任务均完成，刷新界面&quot;);&#125;); 这里我们书写一个网络请求通用方法，假设同时请求某新闻列表的3页数据，每页均为一个独立的网络请求。使用我们最常用的AFNet请求，方法如下（真实开发中可能为banner数据请求、主体网络请求、广告网络请求等）： 12345678910111213141516171819- (void)request_A &#123; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; NSDictionary *parameter = @&#123;@&quot;token&quot;:@&quot;63104AB32427EBF89B957BBD1A5C5C11&quot;, @&quot;page&quot;:@&quot;1&quot;, @&quot;upTime&quot;:@&quot;desc&quot;&#125;; [manager POST:URL parameters:parameter progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; for (NSDictionary *rowsDict in dict[@&quot;rows&quot;]) &#123; NSLog(@&quot;A___%@&quot;,rowsDict[@&quot;title&quot;]); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; &#125;];&#125; request_B、request_C分别为请求第二页与第三页数据，这里不重复书写。为了显示更加明显，在请求中打印了对应新闻的标题内容。 12345678910111213141516 任务均完成，刷新界面C___搞笑，不是认真的C___摄影 | 街拍C___生活小窍门C___传统中国C___想吃的美食系列B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐A___左爱情，右面包A___潮我看A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍 运行后马上接收到了线程组完成的提示，之后数据才依次请求下来，很明显三个单纯的AFNet请求已经不能满足我们的需求了。线程组完成时并没有在我们希望的时候给予通知。在真实开发中会造成的问题为多个请求均加载完成，但界面已在未得到数据前提前刷新导致界面空白。 因此对于这种问题需要另辟蹊径，这里我们就要借助GCD中的信号量dispatch_semaphore进行实现，即营造线程同步情况。dispatch_semaphore信号量为基于计数器的一种多线程同步机制。用于解决在多个线程访问共有资源时候，会因为多线程的特性而引发数据出错的问题。 如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。 dispatch_semaphore_signal(semaphore)为计数+1操作。dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。我们将网络请求通用方法进行修改如下： 1234567891011121314151617181920212223242526- (void)request_A &#123; //创建信号量并设置计数默认为0 dispatch_semaphore_t sema = dispatch_semaphore_create(0); AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; NSDictionary *parameter = @&#123;@&quot;token&quot;:@&quot;63104AB32427EBF89B957BBD1A5C5C11&quot;, @&quot;page&quot;:@&quot;1&quot;, @&quot;upTime&quot;:@&quot;desc&quot;&#125;; [manager POST:URL parameters:parameter progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; //计数+1操作 dispatch_semaphore_signal(sema); NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; for (NSDictionary *rowsDict in dict[@&quot;rows&quot;]) &#123; NSLog(@&quot;A___%@&quot;,rowsDict[@&quot;title&quot;]); &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; ////计数+1操作 dispatch_semaphore_signal(sema); &#125;]; //若计数为0则一直等待 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);&#125; 为方便阅读，伪代码如下： 123456 dispatch_semaphore_t sema = dispatch_semaphore_create(0);[网络请求:&#123; 成功：dispatch_semaphore_signal(sema); 失败：dispatch_semaphore_signal(sema);&#125;];dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); 这时我们再运行程序，打印如下： 12345678910111213141516C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装C___搞笑，不是认真的A___左爱情，右面包A___潮我看A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐任务均完成，刷新界面 运行打印可见，通过信号量dispatch_semaphore完美的解决了此问题，并且网络请求仍为异步，不会堵塞当前主线程。 二、某界面存在多个请求，希望请求依次执行。 对于这个问题通常会通过线程依赖进行解决，因使用GCD设置线程依赖比较繁琐，这里通过NSOperationQueue进行实现，这里采用比较经典的例子，三个任务分别为下载图片，打水印和上传图片，三个任务需异步执行但需要顺序性。代码如下，下载图片、打水印、上传图片仍模拟为分别请求新闻列表3页数据。 12345678910111213141516171819202122//1.任务一：下载图片 NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_A]; &#125;]; //2.任务二：打水印 NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_B]; &#125;]; //3.任务三：上传图片 NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123; [self request_C]; &#125;]; //4.设置依赖 [operation2 addDependency:operation1]; //任务二依赖任务一 [operation3 addDependency:operation2]; //任务三依赖任务二 //5.创建队列并加入任务 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO]; 首先我们使用未添加信号量dispatch_semaphore时运行，打印如下: 123456789101112131415 B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐A___潮我看A___左爱情，右面包A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍C___盘C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装 根据打印结果可见，若不对请求方法做处理，其运行结果并不是我们想要的，联系实际需求，A、B、C请求分别对应下载图片、打水印、上传图片，而此时运行顺序则为B-&gt;A-&gt;C，在未获得图片时即执行打水印操作明显是错误的。重复运行亦会出现不同结果，即请求不做处理，其结果不可控无法预测。线程依赖设置并未起到作用。 解决此问题的方法仍可通过信号量dispatch_semaphore进行解决。我们将请求方法替换为添加dispatch_semaphore限制的形式。即 123456 dispatch_semaphore_t sema = dispatch_semaphore_create(0);[网络请求:&#123; 成功：dispatch_semaphore_signal(sema); 失败：dispatch_semaphore_signal(sema);&#125;]dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); 再次重复运行，我们会发现每次运行结果均一致，A、B、C三任务异步顺序执行（A-&gt;B-&gt;C） 123456789101112131415 A___潮我看A___左爱情，右面包A___世界各国的人们怎么过情人节A___一点创意点亮生活A___摄影 | 随手拍B___时间的见证者B___没事 来吐槽吧……B___触动心灵的摄影B___摄影 | 黑白印记B___每日插画推荐C___盘C___聆听的耳朵C___家居 | 你的家里还缺点什么？C___logo设计C___时装 通过重复运行打印结果可证实确实实现了我们想要的效果。这样即解决了所提出的问题二。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己动手构造编译系统：编译、汇编与链接笔记2]]></title>
      <url>%2F2017%2F06%2F07%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B02%2F</url>
      <content type="text"><![CDATA[本次笔记比上次更有难度，因为涉及到汇编的只是，由于汇编涉及的比较底层，而且自己对于汇编有很多还不了解，所以在写完此次课程开始恶补汇编知识，以此来深入理解本书的内容，而且后期的汇编器也深入讨论汇编知识，所以就此通过这次机会学习一下汇编来补习知识。 我们写一个最简单的“HelloWorld”程序，代码存储在源文件hello.c中，源文件内容如下： 123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;Hello World!&quot;); return 0;&#125; 如果将hello.c编译并静态链接为可执行文件，查看GCC背后的工作流程，可以使用–verbose选项如下(主意针对Mac 命令会有所不同 查看)： 1$gcc hello.c –o hello -S --verbose 通过文件夹目录可以看出多出两个文件 main.s汇编文件和main可执行文件。可以看出，GCC编译背后使用了cc1、as、collect2三个命令。其中cc1是GCC的编译器，它将源文件hello.c编译为hello.s。as是汇编器命令，它将hello.s汇编为hello.o目标文件。collect2是链接器命令，它是对命令ld的封装。静态链接时，GCC将C语言运行时库（CRT）内的5个重要的目标文件crt1.o、crti.o、crtbe-ginT.o、crtend.o、crtn.o以及3个静态库libgcc.a、libgcc_eh.a、libc.a链接到可执行文件hello。此外，cc1在对源文件编译之前，还有预编译的过程。 1.预编译 GCC对源文件的第一阶段的处理是预编译，主要是处理宏定义和文件包含等信息。命令格式如下： 1gcc -E main.c -o main.i 预编译器将hello.c处理后输出到文件hello.i。比如文件包含语句#include，预编译器会将stdio.h的文件内容拷贝到#include语句声明的位置。如果源文件内使用#define语句定义了宏，预编译器则将该宏的内容替换到其被引用的位置。如果宏定义本身使用了其他宏，则预编译器需要将宏递归地展开。 我们可以将预编译的工作简单地理解为源码的文本替换，即将宏定义的内容替换到宏的引用位置。当然，这样理解有一定的片面性，因为要考虑宏定义中使用其他宏的情况。事实上预编译器的实现机制和编译器有着很大的相似性，因此本书描述的编译系统将重点放在源代码的编译上，不再独立实现预编译器。然而，我们需要清楚的事实是：一个完善的编译器是需要预编译器的。 2.编译 接下来GCC对hello.i进行编译，命令如下： 1$gcc –S hello.i –o hello.s编译后产生的汇编文件hello.s 3.汇编 接着，GCC使用汇编器对hello.s进行汇编，命令如下： 1$gcc –c hello.s –o hello.o 生成的目标文件hello.o，Linux下称之为可重定位目标文件。目标文件无法使用文本编辑器直接查看，但是我们可以使用GCC自带的工具objdump命令分析它的内容，命令格式如下： 1$objdump –sd hello.o 从数据段二进制信息的ASCII形式的显示中，我们看到了汇编语言内定义的字符串数据“Hello World！”。代码段的信息和汇编文件代码信息基本吻合，但是我们发现了很多不同之处。比如汇编文件内的指令“movl$.LC0，%eax”中的符号.LC0的地址（字符串“Hello World！”的地址）被换成了0。指令“callprintf”内符号printf的相对地址被换成了0xfffffffc，即call指令操作数部分的起始地址。这些区别本质来源于汇编语言符号的引用问题。由于汇编器在处理当前文件的过程中无法获悉符号的虚拟地址，因此临时将这些符号地址设置为默认值0，真正的符号地址只有在链接的时候才能确定。 4.链接 使用GCC命令进行目标文件链接很简单： 1gcc hello.o –o hello GCC默认使用动态链接，如果要进行静态链接，需加上-static选项： 1gcc hello.o –o hello –static 这样生成的可执行文件hello便能正常执行了。我们使用objdump命令查看一下静态链接后的可执行文件内的信息。由于可执行文件中包含了大量的C语言库文件，因此这里不便将文件的所有信息展示出来，仅显示最终main函数的可执行代码。 从main函数的可执行代码中，我们发现汇编过程中描述的无法确定的符号地址信息在这里都被修正为实际的符号地址。如“Hello World！”字符串的地址为0x080ae828，printf函数的地址为0x08048dd0。这里符号_IO_printf与printf完全等价，call指令内部相对地址为0x000afa，正好是printf地址相对于call指令下条指令起始地址0x080482d6的偏移。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫写入CSV]]></title>
      <url>%2F2017%2F06%2F04%2FPython%E7%88%AC%E8%99%AB%E5%86%99%E5%85%A5CSV%2F</url>
      <content type="text"><![CDATA[这次主要练习写入操作，普通基础的爬虫工作做好之后, 可以进行数据分析等等工作，所以爬虫好的数据就要进行写入操作。直接以糗事百科的爬虫当拿手的例子。Talk is cheap, talk is cheap show me the code. 12345678910111213import requestsimport csvfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)csvfile = open(&quot;qiushi.csv&quot;,&quot;a&quot;) writer = csv.writer(csvfile)for link in links: print(link.span.get_text()) writer.writerow([link.span.get_text()])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己动手构造编译系统：编译、汇编与链接笔记1]]></title>
      <url>%2F2017%2F06%2F04%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%9E%84%E9%80%A0%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[从此分类章节开始针对计算机原理进行系统巩固与加深了解，由于工作做软件开发，时常很少能有时间系统的回顾与深入了解计算机系统内部原理，此书是很好的一本书，值得广大同行有兴趣的深入了解与学习。 源代码通过编译器进行编译生成二进制目标文件，然后对目标文件进行链接，最后生成一个可执行文件。可是计算机只能识别二进制指令，因此需要一个已有的程序自动完成汇编语言到二进制指令的翻译工作，于是汇编器就产生了。程序员只需要写出汇编代码，然后交给汇编器进行翻译，生成二进制代码。因此，汇编器将程序员从烦琐的二进制代码中解脱出来。使用汇编器提高了编程的效率，使得人们有能力处理更复杂的计算问题。随着计算问题复杂度的提高，编程中出现了大量的重复代码。人们不愿意进行重复的劳动，于是就想办法将公共的代码提取出来，汇编成独立的模块存储在目标文件中，甚至将同一类的目标文件打包成库。由于原本写在同一个文件内的代码被分割到多个文件中，那么最终还需要将这些分离的文件拼装起来形成完整的可执行代码。但是事情并没有那么简单，由于文件的模块化分割，文件间的符号可能会相互引用。人们需要处理这些引用关系，重新计算符号的引用地址，这就是链接器的基本功能。链接器使得计算机能自动把不同的文件模块准确无误地拼接起来，使得代码的复用成为可能。 链接分为两种，一种是静态链接，另外一种就是动态链接。静态链接器把公用库内的目标文件合并到可执行文件内部，使得可执行文件的体积变得庞大。这样做会导致可执行文件版本难以更新，也导致了多个程序加载后相同的公用库代码占用了多份内存空间。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。。动态链接器不会把公用库内的目标文件合并到可执行文件内，而仅仅记录动态链接库的路径信息。它允许程序运行前才加载所需的动态链接库，如果该动态链接库已加载到内存，则不需要重复加载。另外，动态链接器也允许将动态链接库的加载延迟到程序执行库函数调用的那一刻。这样做，不仅节约了磁盘和内存空间，还方便了可执行文件版本的更新。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一)]]></title>
      <url>%2F2017%2F05%2F28%2FPython%E7%88%AC%E8%99%AB%E5%88%A9%E5%99%A8%E4%B9%8B%E4%BD%BF%E7%94%A8BeautifulSoup%E6%8A%93%E5%8F%96%E6%89%80%E9%9C%80%E5%86%85%E5%AE%B9(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[Python爬虫利器之使用BeautifulSoup抓取所需内容(一) 最近由于兴趣使然，对于Python爬虫产生了兴趣，所以平时生活中会抽出功夫学习爬虫，文章是自己的爬虫基础实例，以后博客不仅会有iOS的内容，也会Python爬虫，记录自己的代码生涯。 以糗事百科为例来说明，http://www.qiushibaike.com/text/，抓取原创笑话段子。 .png) 发现内容都在span标签中，如果写 find_all(“span”) 可以抓取到段子的内容，但是还包含了网页上其他span的内容。这时我们往上一级标签上看，&lt;div class=”content&gt; 就是只包含了段子内容的标签。取出来的link的内容就是div，取它的span中的内容就是我们需要段子的内容。 1234567891011import requestsfrom bs4 import BeautifulSouphtml = requests.get(&apos;http://www.qiushibaike.com/text/&apos;).contentsoup = BeautifulSoup(html,&apos;lxml&apos;)links = soup.find_all(&apos;div&apos;,class_=&apos;content&apos;)for link in links: print(link.span.get_text())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AutoRelease深入理解原理]]></title>
      <url>%2F2017%2F05%2F13%2FAutoRelease%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？ Autorelease对象什么时候释放？ 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。我们都是知道：所有autorelease的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。但是如果每次都放进应用程序的main.m中的autoreleasepool中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？在一次完整的运行循环结束之前，会被销毁。 那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。 但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。 @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instancetype和id区别]]></title>
      <url>%2F2017%2F05%2F13%2Finstancetype%E5%92%8Cid%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[id在编译的时候不能判断对象的真实类型，而instancetype在编译的时候可以判断对象的真实类型，id和instancetype除了一个在编译时不知道真实类型, 一个在编译时知道真实类型以外, 还有一个区别，id可以用来定义变量, 可以作为返回值, 可以作为形参，instancetype只能用于作为返回值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中self.和下划线的区别]]></title>
      <url>%2F2017%2F03%2F18%2FiOS%E4%B8%ADself.%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[self.xxx 通过访问的方法的引用:包含了set和get方法。而通过_.xxx方法是获取自己的实例变量，不包含set和get方法。 self.xxx是对属性的访问；而xxx是对局部变量的访问。所有被声明为属性的成员，再ios5之前需要使用编译指令@synthesize 来告诉编译器帮助生成属性的getter和setter方法，之后这个指令可以不用认为的指定了，默认情况下编译器会帮助我们生成。编译器在生成getter，setter方法时是有优先级的，他首先查找当前的类中用户是否定义属性的getter，setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。也就是说你在使用self.xxx时是调用一个getter方法。会使引用计数加1，而.xxx不会使用引用技术加1的。 所有使用self.xxx是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在block中造成循环引用。同时使用_.xxx是获取不到父类的属性，因为它只是对局部变量的访问。 最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。]]></content>
    </entry>

    
  
  
</search>
