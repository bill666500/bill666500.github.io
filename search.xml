<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[AutoRelease深入理解原理]]></title>
      <url>%2F2017%2F05%2F13%2FAutoRelease%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？ Autorelease对象什么时候释放？ 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[instancetype和id区别]]></title>
      <url>%2F2017%2F05%2F13%2Finstancetype%E5%92%8Cid%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[id在编译的时候不能判断对象的真实类型，而instancetype在编译的时候可以判断对象的真实类型，id和instancetype除了一个在编译时不知道真实类型, 一个在编译时知道真实类型以外, 还有一个区别，id可以用来定义变量, 可以作为返回值, 可以作为形参，instancetype只能用于作为返回值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中self.和下划线的区别]]></title>
      <url>%2F2017%2F03%2F18%2FiOS%E4%B8%ADself.%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[self.xxx 通过访问的方法的引用:包含了set和get方法。而通过_.xxx方法是获取自己的实例变量，不包含set和get方法。 self.xxx是对属性的访问；而xxx是对局部变量的访问。所有被声明为属性的成员，再ios5之前需要使用编译指令@synthesize 来告诉编译器帮助生成属性的getter和setter方法，之后这个指令可以不用认为的指定了，默认情况下编译器会帮助我们生成。编译器在生成getter，setter方法时是有优先级的，他首先查找当前的类中用户是否定义属性的getter，setter方法，如果有，则编译器会跳过，不会再生成，使用用户定义的方法。也就是说你在使用self.xxx时是调用一个getter方法。会使引用计数加1，而.xxx不会使用引用技术加1的。 所有使用self.xxx是更好的选择，因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在block中造成循环引用。同时使用_.xxx是获取不到父类的属性，因为它只是对局部变量的访问。 最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。]]></content>
    </entry>

    
  
  
</search>
